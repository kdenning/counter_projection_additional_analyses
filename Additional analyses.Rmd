---
title: "Counter Projection - Additional Analyses"
author: "Kathryn Denning"
date: "6/18/2020"
output: 
  html_document:
    code_folding: "hide"
    toc: true
    toc_float: true
    dev: png
  pdf_document:
    dev: cairo_pdf
    latex_engine: xelatex
editor_options: 
  chunk_output_type: console
---
```{r set-up, include = FALSE}
#loading packages
library(foreign)
library(reshape2)
library(tidyverse)
library(dplyr)
library(car)
library(haven)
library(psych)
library(lmerTest)
library(sjPlot)
library(reshape2)
library(data.table)
library(emmeans)
library(effects)
library(Cairo)
library(tinytex)
library(rio)

#making it round to three decimal places
options(scipen = 999)
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)

knitr::opts_knit$set(dev.args = list(type = "cairo"))

trace(grDevices:::png, quote({
  if (missing(type) && missing(antialias)) {
    type <- "cairo-png"
    antialias <- "subpixel"
  }
}), print = FALSE)
```

```{r data import and cleaning initial study, include = FALSE}
#importing data with IP address and lat/long to look for MTurk bots
bot_check <- Import("ppt1_with lat long to check bots.csv") 

bot_check <- bot_check[-c(1,2),,drop = F] 

#importing the data that has been reviewed for completion of PT task
wide_data <- Import("ppt1_fulldata_ptcleanedonly.xlsx") 

#dropping the longer description of each question
wide_dropped1 <- wide_data[-c(1),,drop = F] 

#removing repeat IP addresses since those often indicate bots
#getting a dataset with only subid and IPAdress
ip <- bot_check %>% 
  select(subid, IPAddress)

#identifying the repeat IP addresses
repeat_ips <- ip$IPAddress[duplicated(ip$IPAddress)]

#getting the corresponding subids
bot_check %>% 
  select(subid, IPAddress, LocationLatitude, LocationLongitude) %>% 
  filter(IPAddress %in% c("24.241.223.182", "72.79.119.56", "108.230.124.237", "172.97.7.163", "67.236.228.7", "68.190.36.43"))

#removing the subids from the overall dataset that has already been cleaned to remove people who did not correctly complete the PT narrative task
no_bots <- wide_data %>% 
  filter(!subid %in% c(96, 99, 166, 167, 171, 239, 265, 345, 613, 758, 778, 779))

no_bots <- no_bots[-c(1), ] 
#Data cleaning
clean_data <- no_bots %>% 
  ## drop two MFQ items that aren't actually the survey - 6, 22 in each
select(-MFQSelf_6, -MFQSelf_22, -MFQTrump_6, -MFQTrump_22, -MFQClin_6,
       -MFQClin_22, -MFQTarg_6, -MFQTarg_22) %>% 
  ## dropping PANAS and exploratory items for this study to make data more manageable
  select(-c(PANAS1_1:PANAS1_20, PANAS2_1:PANAS2_20, 
            gender_writein, race_writein, birth_writein, race_writein, 
            language_writein, raise_writein)) %>% 
  mutate_if(is.factor, as.numeric) %>% 
  ### Wrangling data to get MFQ for self, MFQ to targ, MFQ for stereotype, column for candidate, average of IG identification
  gather("MFQ_Type", "MFQ_Score", MFQSelf_1:MFQTarg_32) %>% 
  separate(.,MFQ_Type, c("MFQ_Type", "MFQ_Number"),"\\_") %>% 
  spread(MFQ_Type, MFQ_Score) %>% 
  gather("IG_Type", "IG_Score", IG_Clin_1:IG_Trump_14) %>% 
  separate(.,IG_Type, c("Drop", "IG_Type", "IG_Number"),"\\_") %>% 
  filter(!is.na(IG_Score)) %>% 
  group_by(subid) %>% 
  #average of in-group identification for each subject
  #making candidate they voted for a factor
  mutate(Cand_votedfor = ifelse(IG_Type == "Clin", 1, 
                                ifelse(IG_Type == "Trump", 0, NA))) %>% 
  gather("Day_key", "Day_content", Day_Clin_In_PT:Day_Trump_In_C) %>% 
  mutate(Day_key = as.factor(Day_key)) %>% 
  filter(!is.na(Day_content)) %>% 
  mutate(inoutgroup = fct_collapse(Day_key, 
                                   Ingroup = c("Day_Clin_In_C", 
                                                "Day_Clin_In_PT", 
                                                "Day_Trump_In_C", 
                                                "Day_Trump_In_PT"), 
                                   Outgroup = c("Day_Clin_Out_C", 
                                                "Day_Clin_Out_PT",
                                                "Day_Trump_Out_C", 
                                                "Day_Trump_Out_PT")),
         PT = fct_collapse(Day_key,
                           PT = c("Day_Clin_In_PT",
                                  "Day_Trump_In_PT",
                                  "Day_Clin_Out_PT",
                                  "Day_Trump_Out_PT"),
                           control = c("Day_Clin_In_C",
                                       "Day_Trump_In_C",
                                       "Day_Clin_Out_C",
                                       "Day_Trump_Out_C")),
         par_cand = fct_collapse(Day_key,
                                  Clinton = c("Day_Clin_In_PT",
                                           "Day_Clin_Out_PT",
                                           "Day_Clin_In_C",
                                           "Day_Clin_Out_C"),
                                  Trump = c("Day_Trump_In_PT",
                                            "Day_Trump_Out_PT",
                                            "Day_Trump_In_C",
                                            "Day_Trump_Out_C")),
         targ_cand = fct_collapse(Day_key,
                                  Clinton = c("Day_Clin_In_PT",
                                              "Day_Clin_In_C",
                                              "Day_Trump_Out_PT",
                                              "Day_Trump_Out_C"),
                                  Trump = c("Day_Clin_Out_PT",
                                            "Day_Clin_Out_C",
                                            "Day_Trump_In_PT",
                                            "Day_Trump_In_C")))

clean_data[,1:31] <- sapply(clean_data[,1:31],as.numeric)
clean_data[,34:36] <- sapply(clean_data[,34:36],as.numeric)

clean_data2 <- clean_data %>%
  mutate(IG_ave = mean(IG_Score)) %>% 
  filter(!is.na(IG_ave)) %>% 
  select(-Drop) %>% 
  #effects coding for group with ingroup = .5 and outgorup = -.5, for PT .5 = PT and Control = -.5
  mutate(inoutgroup_effects = ifelse(inoutgroup == "Ingroup", .5,
                                     ifelse(inoutgroup == "Outgroup", -.5, NA)),
         PT_effects = ifelse(PT == "PT", .5, 
                             ifelse(PT == "control", -.5, NA)),
         targ_cand = ifelse(targ_cand == "Clinton", 1, 
                            ifelse(targ_cand == "Trump", 2, NA)),
         MFQStereo = ifelse(par_cand == "Clinton", MFQClin, 
                            ifelse(par_cand == "Trump", MFQTrump, NA))) %>% 
  #grand mean centering MFQ for self
  mutate(MFQSelf_c = MFQSelf - mean(MFQSelf)) %>%  
  #removing people who failed the manipulation check
  filter(targ_cand == 1 & Man_TargVote == 1 | 
           targ_cand == 2 & Man_TargVote == 2) %>%
  select(-Day_content, -Day_key) %>% 
  #effects coding candidate
  mutate(Targ_Cand_effectscoded = ifelse(targ_cand == "1", .5, 
                                         ifelse(targ_cand == "2", -.5, NA)),
         MFQStereo_c = MFQStereo - mean(MFQStereo, na.rm = TRUE))

#for some reason, this wouldn't work in the piping above, so had to hard code it
#grand mean centering for ingroup identification
clean_data2$ident_c <- clean_data2$IG_ave - mean(clean_data2$IG_ave, na.rm = TRUE)
clean_data2$Gender <- as.factor(clean_data2$Gender)
levels(clean_data2$Gender) <- c("Male", "Female", "Other")
clean_data2$Race <- as.factor(clean_data2$Race)
levels(clean_data2$Race) <- c("American Indian/Native Alaskan", 
                             "Asian", 
                             "Black",
                             "Latinx",
                             "Middle Eastern",
                             "Caucasian",
                             "Multiracial",
                             "Other")

#data with just the variables for analysis for stereotyping
stereo_analysis <- clean_data2 %>% 
  select(subid, MFQ_Number, MFQSelf_c, MFQStereo_c, MFQTarg, ident_c, PT_effects, 
         inoutgroup_effects, Man_PT, par_cand) %>%
  unique() %>% 
  na.omit()
```

```{r data import and cleaning F1, include = FALSE}
#Reading in the data
pptnpf1 <- read.csv("PPTNPF1_clean_nopt.csv", header = TRUE) 

correct_mfq <- pptnpf1 %>% 
  select(-MFQ_Self_Check1, -MFQ_Self_Check2, -MFQ_Targ_Check1, -MFQ_Targ_Check2)

#Getting the data in long-format
pptnpf1_comb <-  correct_mfq %>% 
  dplyr::select(Subject, Condition, Gender, Race, Age, Issue_agreement, 
                Identification, ManCheck, 
                MFQSelf.=MFQ_Self_1:MFQ_Self_23, 
                MFQTarg.=MFQ_Targ_1:MFQ_Targ_23) %>% 
  gather(MFQType, MFQResponse, MFQSelf.1:MFQTarg.20, factor_key = TRUE) %>% 
  separate(.,MFQType,c("MFQ","number"),"\\.") %>% 
  spread(.,MFQ, MFQResponse) %>% 
  mutate_each(.,funs(as.numeric(as.character(.)))) %>% 
  group_by(Subject)



#Making each value the right type (numeric or factor) and centered
pptnpf1_comb$MFQSelf_c <- as.numeric(pptnpf1_comb$MFQSelf - 
                                       mean(pptnpf1_comb$MFQSelf, na.rm = TRUE))
pptnpf1_comb$Identification_c <- as.numeric(pptnpf1_comb$Identification - 
                                              mean(pptnpf1_comb$Identification, 
                                                   na.rm = TRUE))
pptnpf1_comb$Condition <- as.factor(pptnpf1_comb$Condition)
pptnpf1_comb$Gender <- as.factor(pptnpf1_comb$Gender)
pptnpf1_comb$Race <- as.factor(pptnpf1_comb$Race)
pptnpf1_comb$Age <- as.numeric(pptnpf1_comb$Age)
pptnpf1_comb <- na.omit(pptnpf1_comb)

#Adding contrast codes for our categorical variable
PRWvPB <- c(1, -1, -1, 3) 
PRvW <- c(-1, -1, 2, 0)  
PvR <- c(-1, 1, 0, 0) 
ConCodes <- cbind(PRWvPB, PRvW, PvR)
contrasts(pptnpf1_comb$Condition) <- ConCodes
contrasts(pptnpf1_comb$Condition)
```

```{r data import and cleaning F2, include = FALSE}

# Data after manually removing participants who did not correctly complete the PT manipulation
npf2_wide <- import("npf2_wide_ptclean2 copy.xlsx") 

# Dropping second row that had full questions and overwriting because don't want that for analyses
npf2_wide <- npf2_wide[-c(1),, drop = F] 

npf2_wide[,1:30] <- sapply(npf2_wide[,1:30],as.factor)
npf2_wide[,32:35] <- sapply(npf2_wide[,32:35],as.numeric)
npf2_wide[,37:40] <- sapply(npf2_wide[,37:40],as.numeric)
npf2_wide[,42:45] <- sapply(npf2_wide[,42:45],as.numeric)
npf2_wide[,47:66] <- sapply(npf2_wide[,47:66],as.numeric)

# Reverse coding
npf2_wide_recode <- npf2_wide %>% 
     mutate_at(c("bfi2xsh_self_quiet", "bfi2xsh_self_rude", 
                 "bfi2xsh_self_disorg", "bfi2xsh_self_taskdiff",
                 "bfi2xsh_self_stable", "bfi2xsh_self_abstract",
                 "bfi2xsh_self_risk", "bfi2xsh_self_uses",
                 "bfi2xsh_targ_quiet", "bfi2xsh_targ_rude",
                 "bfi2xsh_targ_rude", "bfi2xsh_targ_disorg",
                 "bfi2xsh_targ_taskdiff", "bfi2xsh_targ_stable",
                 "bfi2xsh_targ_abstract", "bfi2xsh_targ_risk",
                 "bfi2xsh_targ_uses"), 
               list(~dplyr::recode(., `1`= 5, `2`= 4, `3` = 3, `4` = 2, `5` = 1)))

# Cleaning and putting data in long-format
npf2_clean <- npf2_wide_recode %>% 
  # Dropping open-ended questions
  select(-c(pt_narr_pol, pt_narr_race, pt_narr_thirdpart, pt_narr_weed)) %>% 
  # Making all character variables numeric
  mutate_if(is.character,as.numeric) %>% 
  # Putting responses for personality items into long format for participant and target
  pivot_longer(c(bfi2xsh_self_quiet:bfi2xsh_self_rules, 
           bfi2xsh_targ_quiet:bfi2xsh_targ_rules),
           names_sep = "_",
           names_to = c("drop1", "bfi2xsh_type", "bfi2xsh_qtype")) %>% 
  pivot_wider(names_from = bfi2xsh_type, values_from = value) %>% 
  # Putting responses on other items (conditon, identification, liberal and conservative ratings) into long-format
  pivot_longer(c(opin_pol:check_thirdpart),
               names_sep = "_",
               names_to = c("question", "condition")) %>% 
  na.omit() %>% 
  pivot_wider(names_from = question, values_from = value) %>% 
  select(-drop1) %>% 
  # Making a varriable for perceived polarization, making condition a factor variable
  mutate(perceived_polar = abs(lib-cons),
         condition = fct_relevel(condition, 
                                 "pol", 
                                 "race", 
                                 "weed", 
                                 "thirdpart")) %>% 
  # Mean centering continuous predictors
  mutate(self_c = self - mean(self, na.rm = TRUE),
         ident_c = ident - mean(ident, na.rm = TRUE),
         perceived_polar_c = perceived_polar - 
           mean(perceived_polar, na.rm = TRUE)) %>% 
# Removing opin = 5 for when including the condition variable in the analysis 
# Removing it because only want in and out-group for this analysis, this was an error in data collection to have a third option
  filter(opin != 5) %>% 
  # Removing those who responded incorrectly to the manipulation check
  filter(check != 4)
```

# Stereotyping analysis: Initial Study

```{r stereo analysis}
#model
projmodel_stereo_dem <- lmer(MFQTarg ~ MFQSelf_c * MFQStereo_c *
                                    inoutgroup_effects * ident_c +
                                    (MFQSelf_c|subid), 
                                 data = stereo_analysis)

#results
tab_model(projmodel_stereo_included,
          title = "Projection moderated by stereotyping")

```

```{r}
describe(stereo_analysis$ident_c)
describe(stereo_analysis$inoutgroup_effects)

initial_study_3way <- effect(term = "MFQSelf_c:inoutgroup_effects:ident_c", 
                           xlevels = list(ident_c = c(-1.8, 0, 1.8), 
                                         inoutgroup_effects = c(-.5,.5)), 
                           mod = projmodel_stereo_included)

initial_study_3way <- as.data.frame(initial_study_3way)

initial_study_3way$Group <- as.factor(initial_study_3way$inoutgroup_effects)
initial_study_3way$Identification <- as.factor(initial_study_3way$ident_c)

ident_label <- c("-1.8" = "Low identification \n (1 SD below)", 
                 "0" = "Average identification",
                 "1.8" = "High identificatiion \n(1 SD above)")

```

```{r three-way plot BW}
ggplot(initial_study_3way, aes(MFQSelf_c, 
                             fit, 
                             group = Group, 
                             color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black", 
              aes(linetype = Group)) +
  facet_wrap(~Identification, labeller = 
               labeller(Identification = ident_label)) +
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                   "dashed")) +
  theme_minimal() +
  labs(title = "Projection predicted by in-group identification and group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
```

```{r main effect group plot set-up, include = FALSE}
# getting the information for the main effect of group
initial_study_main_group <- effect(term = "MFQSelf_c:inoutgroup_effects", 
                             xlevels = list(inoutgroup_effects = c(-.5,.5)), 
                             mod = projmodel_stereo_included)

initial_study_main_group <- as.data.frame(initial_study_main_group)

initial_study_main_group$Group <- as.factor(initial_study_main_group$inoutgroup_effects)
```

```{r main effect group plot BW}
ggplot(initial_study_main_group, aes(MFQSelf_c, 
                               fit, 
                               group = Group, 
                               color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black",
              aes(linetype = Group)) +
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                  "dashed")) +
  theme_minimal() +
  labs(title = "Projection predicted by group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
```

These results demonstrate that our significant three-way interaction from before is no longer significant, but the main effect of group identification still is significant and still shows counter projection. The three-way is not significant because, regardless of in-group identification, people are still counter projecting to the same extent with their out-group and projecting normally with their in-group.

## With political affiliation as moderator

```{r stereo analysis by cand}
#model
is_cand <- lmer(MFQTarg ~ MFQSelf_c * MFQStereo_c *
                                    inoutgroup_effects * ident_c * par_cand +
                                    (MFQSelf_c|subid), 
                                 data = stereo_analysis)

#results
tab_model(is_cand,
          title = "Projection moderated by stereotyping")

```

When we include who the participant voted for with stereotyping as well, we still have the main effect from above. Now, the interaction between target group and in-group identification is significant. There is also an interaction between target group (in or out) and who the participant voted for. However, an interaction between target group, degree of in-group identification, and who they voted for is not significant. There are other significant interactions including stereotyping, but, since we only included it as a moderator to see if the relationship persisted, I didn't go through them thoroughly.

```{r is group by cand}
levels(stereo_analysis$par_cand)
# getting the information for the main effect of group
is_group_cand <- effect(term = "MFQSelf_c:inoutgroup_effects:par_cand", 
                             xlevels = list(inoutgroup_effects = c(-.5,.5),
                                            par_cand = c("Clinton", "Trump")), 
                             mod = is_cand)

is_group_cand <- as.data.frame(is_group_cand)

is_group_cand$Group <- as.factor(is_group_cand$inoutgroup_effects)


```

```{r is group by cand}
ggplot(is_group_cand, aes(MFQSelf_c, 
                               fit, 
                               group = Group, 
                               color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black",
              aes(linetype = Group)) +
  facet_wrap(~par_cand)+
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                  "dashed")) +
  theme_minimal() +
  labs(title = "Projection predicted by group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
```   

Clinton supporters counter project and Trump supporters do not. I've checked this a lot and it seems to be correct, I must have messed up in my first year when I analyzed it...


```{r stereo cand 3way set-up}
describe(stereo_analysis$ident_c)
describe(stereo_analysis$inoutgroup_effects)

is_3way_cand <- effect(term = "MFQSelf_c:inoutgroup_effects:ident_c", 
                           xlevels = list(ident_c = c(-1.78, 0, 1.78), 
                                         inoutgroup_effects = c(-.5,.5)), 
                           mod = is_cand)

is_3way_cand <- as.data.frame(is_3way_cand)

is_3way_cand$Group <- as.factor(is_3way_cand$inoutgroup_effects)
is_3way_cand$Identification <- as.factor(is_3way_cand$ident_c)

ident_label <- c("-1.78" = "Low identification \n (1 SD below)", 
                 "0" = "Average identification",
                 "1.78" = "High identificatiion \n(1 SD above)")

```

```{r three-way stereo cand}
ggplot(is_3way_cand, aes(MFQSelf_c, 
                             fit, 
                             group = Group, 
                             color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black", 
              aes(linetype = Group)) +
  facet_wrap(~Identification, labeller = 
               labeller(Identification = ident_label)) +
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                   "dashed")) +
  theme_minimal() +
  labs(title = "Projection predicted by in-group identification and group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
```

```{r main effect group plot set-up cand, include = FALSE}
# getting the information for the main effect of group
is_group_cand <- effect(term = "MFQSelf_c:inoutgroup_effects", 
                             xlevels = list(inoutgroup_effects = c(-.5,.5)), 
                             mod = is_cand)

is_group_cand <- as.data.frame(is_group_cand)

is_group_cand$Group <- as.factor(is_group_cand$inoutgroup_effects)
```

```{r main effect group plot BW cand}
ggplot(is_group_cand, aes(MFQSelf_c, 
                               fit, 
                               group = Group, 
                               color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black",
              aes(linetype = Group)) +
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                  "dashed")) +
  theme_minimal() +
  labs(title = "Projection predicted by group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
```

# MFQ sub areas

```{r mfq subscales}
#separating MFQ into binding and individualizing subscales
mfq_binding <- clean_data2 %>% 
  filter(MFQ_Number %in% c("3", "4", "5", "9", "10", "11", "14", "15", "16", 
                           "19", "20", "21", "25", "26", "27", "30", "31", "32")) %>%
  select(subid, MFQ_Number, MFQTarg, MFQSelf_c, MFQStereo_c, inoutgroup_effects, ident_c, par_cand) %>% 
  unique() %>% 
  na.omit()

mfq_individual <- clean_data2 %>% 
  filter(MFQ_Number %in% c("1", "2", "7", "8", "12", "13", "17", "18", "23", 
                           "24", "28", "29")) %>%
  select(subid, MFQ_Number, MFQTarg, MFQSelf_c, MFQStereo_c, inoutgroup_effects, ident_c, par_cand) %>% 
  unique() %>% 
  na.omit()
```

## Initial Study

### Binding
```{r mfq binding model}
#model
is_mfqbinding <- lmer(MFQTarg ~ MFQSelf_c * MFQStereo_c *
                                    inoutgroup_effects * ident_c +
                                    (MFQSelf_c|subid), 
                                 data = mfq_binding)

#results
tab_model(is_mfqbinding,
          title = "Projection moderated by stereotyping for binding morals")
```

```{r 3 way mfq binding set up}
describe(mfq_binding$ident_c)

is_binding_3way <- effect(term = "MFQSelf_c:inoutgroup_effects:ident_c", 
                           xlevels = list(ident_c = c(-1.78, 0, 1.78), 
                                         inoutgroup_effects = c(-.5,.5)), 
                           mod = is_mfqbinding)

is_binding_3way <- as.data.frame(is_binding_3way)

is_binding_3way$Group <- as.factor(is_binding_3way$inoutgroup_effects)
is_binding_3way$Identification <- as.factor(is_binding_3way$ident_c)

ident_label <- c("-1.78" = "Low identification \n (1 SD below)", 
                 "0" = "Average identification",
                 "1.78" = "High identificatiion \n(1 SD above)")

```

```{r 3way mfq binding plot}
ggplot(is_binding_3way, aes(MFQSelf_c,
                             fit, 
                             group = Group,
                             color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black", 
              aes(linetype = Group)) +
  facet_wrap(~Identification, labeller = 
               labeller(Identification = ident_label)) +
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                   "dashed")) +
  theme_minimal() +
  labs(title = "Projection of binding morals predicted by in-group identification and group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
```

```{r binding main effectgroup plot set-up, include = FALSE}
# getting the information for the main effect of group
is_binding_group <- effect(term = "MFQSelf_c:inoutgroup_effects", 
                             xlevels = list(inoutgroup_effects = c(-.5,.5)), 
                             mod = is_mfqbinding)

is_binding_group <- as.data.frame(is_binding_group)

is_binding_group$Group <- as.factor(is_binding_group$inoutgroup_effects)
```

```{r binding main effect group plot BW}
ggplot(is_binding_group, aes(MFQSelf_c, 
                               fit, 
                               group = Group, 
                               color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black",
              aes(linetype = Group)) +
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                  "dashed")) +
  theme_minimal() +
  labs(title = "Projection of binding morals predicted by group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
```

### Binding including participant vote

```{r mfq binding model cand}
#model
is_mfqbinding_cand <- lmer(MFQTarg ~ MFQSelf_c * MFQStereo_c *
                                    inoutgroup_effects * ident_c * par_cand +
                                    (MFQSelf_c|subid), 
                                 data = mfq_binding)

#results
tab_model(is_mfqbinding_cand,
          title = "Projection moderated by stereotyping for binding morals")
```

Main effect of target group is still significant. Who participants voted for is marginal (.050). The interaction between target group and identification is still significant. The interaction between target group, identification, and who they voted for is not significant.

```{r binding group by cand}
# getting the information for the main effect of group
bind_group_cand <- effect(term = "MFQSelf_c:inoutgroup_effects:par_cand", 
                             xlevels = list(inoutgroup_effects = c(-.5,.5),
                                            par_cand = c("Clinton", "Trump")), 
                             mod = is_mfqbinding_cand)

bind_group_cand <- as.data.frame(bind_group_cand)

bind_group_cand$Group <- as.factor(bind_group_cand$inoutgroup_effects)


```

```{r binding group by cand}
ggplot(bind_group_cand, aes(MFQSelf_c, 
                               fit, 
                               group = Group, 
                               color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black",
              aes(linetype = Group)) +
  facet_wrap(~par_cand)+
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                  "dashed")) +
  theme_minimal() +
  labs(title = "Projection predicted by group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
``` 

### Individualizing

```{r mfq individual model}
#model
is_mfqindividual <- lmer(MFQTarg ~ MFQSelf_c * MFQStereo_c *
                                    inoutgroup_effects * ident_c +
                                    (MFQSelf_c|subid), 
                                 data = mfq_individual)

#results
tab_model(is_mfqindividual,
          title = "Projection moderated by stereotyping for individualizing morals")
```


The main effect of target group is still significant. The interaction between target group and identification is no longer significant, but I plotted it just to show the difference.

```{r 3 way mfq individual set up}
describe(mfq_individual$ident_c)

is_indiv_3way <- effect(term = "MFQSelf_c:inoutgroup_effects:ident_c", 
                           xlevels = list(ident_c = c(-1.78, 0, 1.78), 
                                         inoutgroup_effects = c(-.5,.5)), 
                           mod = is_mfqindividual)

is_indiv_3way <- as.data.frame(is_indiv_3way)

is_indiv_3way$Group <- as.factor(is_indiv_3way$inoutgroup_effects)
is_indiv_3way$Identification <- as.factor(is_indiv_3way$ident_c)

ident_label <- c("-1.78" = "Low identification \n (1 SD below)", 
                 "0" = "Average identification",
                 "1.78" = "High identificatiion \n(1 SD above)")

```

```{r 3way mfq individual plot}
ggplot(is_indiv_3way, aes(MFQSelf_c, 
                             fit, 
                             group = Group, 
                             color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black", 
              aes(linetype = Group)) +
  facet_wrap(~Identification, labeller = 
               labeller(Identification = ident_label)) +
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                   "dashed")) +
  theme_minimal() +
  labs(title = "Projection of individualizing morals predicted by in-group identification and group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
```

```{r individual main effectgroup plot set-up, include = FALSE}
# getting the information for the main effect of group
is_indiv_group <- effect(term = "MFQSelf_c:inoutgroup_effects", 
                             xlevels = list(inoutgroup_effects = c(-.5,.5)), 
                             mod = is_mfqindividual)

is_indiv_group <- as.data.frame(is_indiv_group)

is_indiv_group$Group <- as.factor(is_indiv_group$inoutgroup_effects)
```

```{r indiv main effect group plot BW}
ggplot(is_indiv_group, aes(MFQSelf_c, 
                               fit, 
                               group = Group, 
                               color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black",
              aes(linetype = Group)) +
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                  "dashed")) +
  theme_minimal() +
  labs(title = "Projection of individualizing morals predicted by group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
```

### Individualizing including participant vote

```{r mfq individual model cand}
#model
is_mfqindividual_cand <- lmer(MFQTarg ~ MFQSelf_c * MFQStereo_c *
                                    inoutgroup_effects * ident_c * par_cand +
                                    (MFQSelf_c|subid), 
                                 data = mfq_individual)

#results
tab_model(is_mfqindividual_cand,
          title = "Projection moderated by stereotyping for individual morals")
```


Main effect of target group is still significant. The main effect of who participants voted for is marginal (.077). The interactions between target group and identification  between target group and who participants voted for, and target group, identification, and who participants voted for are all not significant.

```{r individual main effectgroup plot set-up with cand, include = FALSE}
# getting the information for the main effect of group
is_indiv_group_cand <- effect(term = "MFQSelf_c:inoutgroup_effects", 
                             xlevels = list(inoutgroup_effects = c(-.5,.5)), 
                             mod = is_mfqindividual_cand)

is_indiv_group_cand <- as.data.frame(is_indiv_group_cand)

is_indiv_group_cand$Group <- as.factor(is_indiv_group_cand$inoutgroup_effects)
```

```{r indivi main effect group plot with cand}
ggplot(is_indiv_group_cand, aes(MFQSelf_c, 
                               fit, 
                               group = Group, 
                               color = Group)) +
  geom_smooth(method = "lm", se = FALSE, size = .7, colour = "black",
              aes(linetype = Group)) +
  scale_linetype_manual("Group", breaks = c(-.5, .5), 
                       labels = c("Out-group", "In-group"),
                       values = c("solid", 
                                  "dashed")) +
  theme_minimal() +
  labs(title = "Projection of individualizing morals predicted by group membership",
       subtitle = "Controlling for stereotyping",
       x = "MFQ responses for self",
       y = "MFQ responses for target")
```

## Follow-up 1

```{r f1 mfq subscales}
#separating MFQ into binding and individualizing subscales
f1_mfq_binding <- pptnpf1_comb %>% 
  filter(number %in% c("3", "4", "5", "9", "10", "11", "14", "15", "16", 
                           "20", "21", "22")) %>%
  select(Subject, number, Condition, MFQSelf_c, Identification_c, Gender, Race, MFQTarg) %>% 
  unique() %>% 
  na.omit()

f1_mfq_individual <- pptnpf1_comb %>% 
  filter(number %in% c("1", "2", "7", "8", "12", "13", "18", "19")) %>%
  select(Subject, number, Condition, MFQSelf_c, Identification_c, Gender, Race, MFQTarg) %>% 
  unique() %>% 
  na.omit()
```

### Binding

```{r f1 binding model}
f1_binding <- lmer(MFQTarg ~ MFQSelf_c*Identification_c*Condition + 
                              (MFQSelf_c|Subject), 
                            data = f1_mfq_binding, na.action = na.omit)

tab_model(f1_binding,
          title = "Effects of predictors and interactions on projection of binding morals")
```

```{r f1 binding three way,include = FALSE, echo = FALSE}
#Creating label for in-group identification so it can be treated like a categorical variable in the plot
describe(f1_mfq_binding$Identification_c)
Ident_label <- c("-1.19" = "Low identification \n (1 SD below)",
                 "0" = "Average \n identification",
                 "1.19" = "High identification \n (1 SD above)")

#Getting summary stats to plot
f1_binding_summary_3way <-summary(lsmeans(f1_binding , 
                               ~MFQSelf_c|Identification_c|Condition, 
                               at = list (MFQSelf_c = c(-3:3), 
                                          Identification_c = c(-1.19, 0, 1.19))))
```


```{r Three-way BW model f1 binding}
#running the plot

ggpreview <- function(...) {
  fname <- tempfile(fileext = ".png")
  ggsave(filename = fname, ...)
  system2("open", fname)
  invisible(NULL)
}

knitr::opts_chunk$set(fig.width = 8, fig.height = 6) 

ggplot(f1_binding_summary_3way, aes(x = MFQSelf_c, 
                         y = lsmean, 
                         group = as.factor(Condition))) + 
  facet_grid(.~Identification_c,
             labeller = labeller(Identification_c = Ident_label)) + 
  geom_line(size = .7, aes(linetype = Condition)) +
  xlab("MFQ responses for self") + 
  ylab("MFQ responses for target") + 
  scale_linetype_manual("Issue polarization", 
                        breaks = c(1,2,3,4), 
                        labels = c ("Political\ncandidate",
                                   "Racial\ndisadvantage",
                                   "Marijuana\nlegalization",
                                   "Peanut\nbutter"),
                        values = c("solid",
                                   "twodash", 
                                   "dotted", 
                                   "dashed")) + 
  ggtitle("Projection predicted by identification and issue polarization") +
  theme_minimal(base_size = 13) +
  theme(legend.text = element_text(size = 10),
        legend.key.width = unit(1, "cm"),
        legend.position = "bottom")
  
ggpreview(width = 8, height = 6, units = "in")
```

Not much different than the overall, except now average identifiers in the political condition are negatively projecting and people in the racial disadvantage condition who highly identify aren't projecting at all.


```{r f1 binding two-way set-up,include = FALSE, echo = FALSE}
#Get summary stats for plot
f1_binding_sum_cond <-summary(lsmeans(f1_binding, ~MFQSelf_c|Condition, 
                                    at = list(MFQSelf_c = c(-3:3))))
```


```{r f1 binding two-way BW}
knitr::opts_chunk$set(fig.width = 8, fig.height = 6) 

ggplot(f1_binding_sum_cond, aes(x = MFQSelf_c, 
                              y = lsmean, 
                              group = as.factor(Condition)))+
  geom_line(size = 1, aes(linetype = Condition)) +
  xlab("MFQ responses for self") + 
  ylab("MFQ responses for target") + 
  scale_linetype_manual("Issue polarization", 
                      breaks = c(1,2,3,4),
                      labels = c("Political\ncandidate",
                                  "Racial\ndisadvantage", 
                                  "Marijuana\nlegalization",
                                  "Peanut\nbutter"),
                       values = c("solid",
                                   "twodash", 
                                   "dotted", 
                                   "dashed")) +
  ggtitle("Effect of issue polarization on projection with out-group targets") +
  theme_minimal(base_size = 13) +
  theme(legend.text = element_text(size = 10),
        legend.key.width = unit(1.2, "cm"))


ggpreview(width = 8, height = 6, units = "in")
```

Only difference is now there is counter projection in the political candidate condition.

```{r f1 binding ident set-up, include = FALSE}
#information to plot main effect of in-group identification
describe(f1_mfq_binding$Identification_c)

f1_binding_ident <- effect(term ="MFQSelf_c:Identification_c", 
                             xlevels = list(Identification_c = c(-1.19, 0, 1.19)), 
                             mod = f1_binding)

f1_binding_ident <- as.data.frame(f1_binding_ident)

f1_binding_ident$Identification <- as.factor(f1_binding_ident$Identification_c)
```

```{r f1 binding ident plot}
knitr::opts_chunk$set(fig.width = 8, fig.height = 6) 

ggplot(f1_binding_ident, aes(MFQSelf_c, 
                               fit, 
                               group = Identification)) +
  geom_line(aes(linetype = Identification), size = .7) +
  scale_linetype_manual("Identification", 
                       breaks = c(-1.19, 0, 1.19), 
                       labels = c ("Low (1 SD below)", 
                                  "Average ", 
                                  "High (1 SD above)"),
                        values = c("solid",
                                   "twodash", 
                                   "dotted")) +
  theme_minimal(base_size = 13) +
  labs(title = "Projection predicted by degree of in-group identification",
       x = "MFQ responses for self",
       y = "MFQ responses for target")

ggpreview(width = 8, height = 6, units = "in")
```

Pretty similar to the overall model.

### Individualizing

```{r f1 individualizing model}
f1_individual <- lmer(MFQTarg ~ MFQSelf_c*Identification_c*Condition + 
                              (MFQSelf_c|Subject), 
                            data = f1_mfq_individual, na.action = na.omit)

tab_model(f1_individual,
          title = "Effects of predictors and interactions on projection of individualizing morals")
```

The results of this model are also not that different from the overall model: the main effects of condition and identification are still significant, as well as the interaction between condition and identification.


```{r f1 indiv three way,include = FALSE, echo = FALSE}
#Creating label for in-group identification so it can be treated like a categorical variable in the plot
describe(f1_mfq_individual$Identification_c)
Ident_label <- c("-1.19" = "Low identification \n (1 SD below)",
                 "0" = "Average \n identification",
                 "1.19" = "High identification \n (1 SD above)")

#Getting summary stats to plot
f1_individual_summary_3way <-summary(lsmeans(f1_individual, 
                               ~MFQSelf_c|Identification_c|Condition, 
                               at = list (MFQSelf_c = c(-3:3), 
                                          Identification_c = c(-1.19, 0, 1.19))))
```


```{r Three-way BW model f1 individual}
#running the plot

ggpreview <- function(...) {
  fname <- tempfile(fileext = ".png")
  ggsave(filename = fname, ...)
  system2("open", fname)
  invisible(NULL)
}

knitr::opts_chunk$set(fig.width = 8, fig.height = 6) 

ggplot(f1_individual_summary_3way, aes(x = MFQSelf_c, 
                         y = lsmean, 
                         group = as.factor(Condition))) + 
  facet_grid(.~Identification_c,
             labeller = labeller(Identification_c = Ident_label)) + 
  geom_line(size = .7, aes(linetype = Condition)) +
  xlab("MFQ responses for self") + 
  ylab("MFQ responses for target") + 
  scale_linetype_manual("Issue polarization", 
                        breaks = c(1,2,3,4), 
                        labels = c ("Political\ncandidate",
                                   "Racial\ndisadvantage",
                                   "Marijuana\nlegalization",
                                   "Peanut\nbutter"),
                        values = c("solid",
                                   "twodash", 
                                   "dotted", 
                                   "dashed")) + 
  ggtitle("Projection predicted by identification and issue polarization") +
  theme_minimal(base_size = 13) +
  theme(legend.text = element_text(size = 10),
        legend.key.width = unit(1, "cm"),
        legend.position = "bottom")
  
ggpreview(width = 8, height = 6, units = "in")
```

Interesting! With individualizing morals, people counter project more in the political condition when they are average identified than in the overall model and people strongly counter project in both the political and racial disadvantage conditions when highly identified. The overall model did not show counter projection in the racial disadvantage condition when people were highly identified.


```{r f1 indiv two-way set-up,include = FALSE, echo = FALSE}
#Get summary stats for plot
f1_indiv_sum_cond <-summary(lsmeans(f1_individual, ~MFQSelf_c|Condition, 
                                    at = list(MFQSelf_c = c(-3:3))))
```

```{r f1 indiv two-way BW}
knitr::opts_chunk$set(fig.width = 8, fig.height = 6) 

ggplot(f1_indiv_sum_cond, aes(x = MFQSelf_c, 
                              y = lsmean, 
                              group = as.factor(Condition)))+
  geom_line(size = 1, aes(linetype = Condition)) +
  xlab("MFQ responses for self") + 
  ylab("MFQ responses for target") + 
  scale_linetype_manual("Issue polarization", 
                      breaks = c(1,2,3,4),
                      labels = c("Political\ncandidate",
                                  "Racial\ndisadvantage", 
                                  "Marijuana\nlegalization",
                                  "Peanut\nbutter"),
                       values = c("solid",
                                   "twodash", 
                                   "dotted", 
                                   "dashed")) +
  ggtitle("Effect of issue polarization on projection with out-group targets") +
  theme_minimal(base_size = 13) +
  theme(legend.text = element_text(size = 10),
        legend.key.width = unit(1.2, "cm"))


ggpreview(width = 8, height = 6, units = "in")
```

Only difference is now there is counter projection in the political candidate condition and the racial disadvantage condition is pretty flat.

```{r f1 indiv ident set-up, include = FALSE}
#information to plot main effect of in-group identification
describe(f1_mfq_individual$Identification_c)

f1_indiv_ident <- effect(term ="MFQSelf_c:Identification_c", 
                             xlevels = list(Identification_c = c(-1.19, 0, 1.19)), 
                             mod = f1_individual)

f1_indiv_ident  <- as.data.frame(f1_indiv_ident)

f1_indiv_ident$Identification <- as.factor(f1_indiv_ident$Identification_c)
```

```{r f1 binding ident plot}
knitr::opts_chunk$set(fig.width = 8, fig.height = 6) 

ggplot(f1_indiv_ident, aes(MFQSelf_c, 
                               fit, 
                               group = Identification)) +
  geom_line(aes(linetype = Identification), size = .7) +
  scale_linetype_manual("Identification", 
                       breaks = c(-1.19, 0, 1.19), 
                       labels = c ("Low (1 SD below)", 
                                  "Average ", 
                                  "High (1 SD above)"),
                        values = c("solid",
                                   "twodash", 
                                   "dotted")) +
  theme_minimal(base_size = 13) +
  labs(title = "Projection predicted by degree of in-group identification",
       x = "MFQ responses for self",
       y = "MFQ responses for target")

ggpreview(width = 8, height = 6, units = "in")
```

Pretty similar to the original.

# BFI sub sreas: Follow-up 2

Did this previously in another document, which I have uploaded to this project.

# Political ideology breakdown of counter projection

## Initial Study - already did this above with who they voted for

## Follow-up 1

Look at whether or not they agreed or disagreed with the issue AND if the issue is generally liberal or conservative.

Condition: What issue participants were given; 1 = political candidate, 2 = racial discrimination, 3 = weed, 4 = PB

Issue_agreement: 1 for condition 1 is Clinton, 2 is Trump, for other three conditions 1 is yes to agreeing with issue, 4 is no to agreeing with issue (AKA ignoring PB, 1 = liberal, 4 = conservative beliefs)

```{r f1 ideology}
f1_ideology_model <- lmer(MFQTarg ~ MFQSelf_c*Identification_c*Condition*Issue_agreement + 
                              (MFQSelf_c|Subject), 
                            data = pptnpf1_comb, na.action = na.omit)

tab_model(f1_ideology_model,
          title = "Projection predicted by ideology")
```

```{r f1 issue agree plot 1}
describe(pptnpf1_comb$Identification_c)

effects_polident_f1 <- effect(term="MFQSelf_c:Identification_c:Condition", 
                        xlevels= list(Identification_c=c(-1.19, 0, 1.19), 
                                      Condition=c("1",
                                                  "2",
                                                  "3",
                                                  "4")), 
                        mod=f1_ideology_model)

effects_polident_f1 <- as.data.frame(effects_polident_f1)

effects_polident_f1$Identification<-as.factor(effects_polident_f1$Identification_c)

f1_polident_ident_label <- c("-1.19"="Low Identification \n(1 SD Below)", 
                       "0" = "Average \nIdentification",
                       "1.19"="High Identification \n(1 SD Above)")

#three-way interaction
ggplot(effects_polident_f1, aes(MFQSelf_c, fit)) +
  #geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill = Condition), alpha = .3) +
  geom_line(size = 1, aes(linetype = Condition)) +
  facet_wrap(~Identification, 
             labeller = labeller(Identification=f1_polident_ident_label)) +
  scale_linetype_manual("Issue polarization", 
                        breaks = c(1,2,3,4), 
                        labels = c ("Political\ncandidate",
                                   "Racial\ndisadvantage",
                                   "Marijuana\nlegalization",
                                   "Peanut\nbutter"),
                        values = c("solid",
                                   "twodash", 
                                   "dotted", 
                                   "dashed")) +
    theme_minimal(base_size = 13) +
  theme(legend.text = element_text(size = 10),
        legend.key.width = unit(1.2, "cm")) +
  labs(title = "Projection predicted by in-group identification and condition",
       subtitle = "Included issue agreement in this model",
       x = "MFQ ratings for self",
       y = "MFQ ratings for target")
```

```{r f1 issue agree plot 2}
describe(pptnpf1_comb$Issue_agreement)

effects_polident_f1_plot2 <- effect(term="MFQSelf_c:Condition:Issue_agreement", 
                        xlevels= list(Issue_agreement=c(1, 4), 
                                      Condition=c("1",
                                                  "2",
                                                  "3",
                                                  "4")), 
                        mod=f1_ideology_model)

effects_polident_f1_plot2 <- as.data.frame(effects_polident_f1_plot2)

effects_polident_f1_plot2$Agreement<-as.factor(effects_polident_f1_plot2$Issue_agreement)

f1_polident_ident_label2 <- c("1" = "Support Clinton, Acknowledge racism, \n Weed legalization, and Smooth PB",
                             "4" = "Support Trump, Did not acknowledge racism, \n disagree with weed legalization, like crunchy peanut butter")

#three-way interaction
ggplot(effects_polident_f1_plot2, aes(MFQSelf_c, fit)) +
  #geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill = Condition), alpha = .3) +
  geom_line(size = 1, aes(linetype = Condition)) +
  facet_wrap(~Agreement, 
             labeller = labeller(Agreement=f1_polident_ident_label2)) +
  scale_linetype_manual("Issue polarization", 
                        breaks = c(1,2,3,4), 
                        labels = c ("Political\ncandidate",
                                   "Racial\ndisadvantage",
                                   "Marijuana\nlegalization",
                                   "Peanut\nbutter"),
                        values = c("solid",
                                   "twodash", 
                                   "dotted", 
                                   "dashed")) +
    theme_minimal(base_size = 13) +
  theme(legend.text = element_text(size = 10),
        legend.key.width = unit(1.2, "cm")) +
  labs(title = "Projection predicted by  issue condition and issue agreement",
       x = "MFQ ratings for self",
       y = "MFQ ratings for target")
```

## Follow-up 2

  * **opin** : Whether participants agreed or disgareed with the issue they were presented (e.g., Do you support marijuana legalization?)
    + 1 = Yes
    + 4 = No
    
```{r f2 ideology}
contrasts(npf2_clean$condition) <- "contr.helmert"

f2_ideology_model <- lmer(targ ~ self_c*ident_c*condition*opin + 
                              (self_c|sub_id), 
                            data = npf2_clean, na.action = na.omit)

tab_model(f2_ideology_model,
          title = "Projection predicted by ideology")
```

Model failed to converge, so results are unreliable. Any plot using intercepts and slopes from this model would also be unreliable.

# Demographic differences in counter projection

## Initial Study - Gender & race

```{r stereo analysis with race}
dem_analysis <- clean_data2 %>% 
  select(subid, MFQ_Number, MFQSelf_c, MFQStereo_c, MFQTarg, ident_c, PT_effects, 
         inoutgroup_effects, par_cand, Race) %>%
  unique() %>% 
  na.omit()

#model
projmodel_stereo_race <- lmer(MFQTarg ~ MFQSelf_c * MFQStereo_c *
                                    inoutgroup_effects * ident_c * Race +
                                    (MFQSelf_c|subid), 
                                 data = dem_analysis)

#results
tab_model(projmodel_stereo_race,
          title = "Projection moderated by stereotyping and race")

```

Model is rank deficient, not enough power to check if results differ by race. Could possibly do white vs minorities, but that doesn't feel telling enough.

```{r stereo analysis with gender}
gender_analysis <- clean_data2 %>% 
  select(subid, MFQ_Number, MFQSelf_c, MFQStereo_c, MFQTarg, ident_c, PT_effects, 
         inoutgroup_effects, par_cand, Gender) %>%
  unique() %>% 
  na.omit()

#model
projmodel_stereo_gender <- lmer(MFQTarg ~ MFQSelf_c * MFQStereo_c *
                                    inoutgroup_effects * ident_c * Gender +
                                    (MFQSelf_c|subid), 
                                 data = gender_analysis)

#results
tab_model(projmodel_stereo_gender,
          title = "Projection moderated by stereotyping and gender")

```

Gender does not moderate the results.

## Follow-up 1 - Gender

## Follow-up 1 - Race

## Follow-up 2 - Gender

## Follow-up 2 - Race

# Downstream outcomes impacted by counter projection - Initial Study

# Look at how they respond for in-group to address demand? Does this mean looking at whether they are approve or disapprove of the condition in F1 and F2? Could do liberal leaning vs conservative leaning, minus PB and third party

# Alphas for the MFQ